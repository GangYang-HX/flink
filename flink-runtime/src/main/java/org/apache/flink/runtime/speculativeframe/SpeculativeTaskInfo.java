/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.runtime.speculativeframe;

import org.apache.flink.annotation.VisibleForTesting;
import org.apache.flink.util.ExceptionUtils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

public class SpeculativeTaskInfo {

    private static final Logger LOG = LoggerFactory.getLogger(SpeculativeTaskInfo.class);

    /**
     * The failure info updater.
     * It could guarantee update {@link #finalfailureInfo} thread safety.
     */
    private static final AtomicReferenceFieldUpdater<SpeculativeTaskInfo, TaskFailureInfo> FAILURE_INFO_UPDATER =
            AtomicReferenceFieldUpdater.newUpdater(
                    SpeculativeTaskInfo.class,
                    TaskFailureInfo.class,
                    "finalfailureInfo");

    /**
     * Identifies the type of the task. This id is used to associate
     * this task with the options of the task. The data will also so grouped by this
     * id and counted.
     */
    private final String taskType;

    /**
     * Generates some data that the task understands. This will be called both for the
     * original task and the speculative task. The data generated for them can be
     * different.
     * Example:
     *      A UUID string generator can be used when uploading file to HDFS. And the
     *      generated string can be used as the file name of the temporary file name.
     */
    @Nullable
    private final Supplier<Object> taskDataGenerator;

    /**
     * The work for the task. The argument is the result generated by
     * {@link #taskDataGenerator}. The result of the function will be passed to
     * {@link #succeedCallback} and {@link #duplicatedTaskSucceedsCallback}.
     *
     * Example:
     *      The UUID string passed in can be returned as the result when uploading
     *      file to HDFS. And the result can be renamed to the target file name.
     */
    @Nonnull
    private final Function<Object, Object> task;

    /**
     * This is used to cancel the original task (when speculative task succeeds before the
     * original task) or the speculative task (when the original task succeeds before the
     * speculative task).
     */
    @Nullable
    private final Consumer<Future<?>> taskCanceller;

    /**
     * This will be called once (for the original submitted task, or for the speculative task).
     * If {@link #taskCanceller} is not supplied, there's chance both the original task and
     * the speculative task succeed. Only the first succeeded task's callback will be called.
     * Example:
     *      In HDFS file uploading, the user can renaming the temporary file to the target file
     *      in this callback.
     */
    @Nullable
    private final Consumer<Object> succeedCallback;

    /**
     * This will only be called when the final results of both tasks (if speculated task was
     * submitted) were produced, or the result of the original task was produced. The
     * callback can decide what to do based on the final result instead of an intermediate
     * result.
     */
    @Nonnull
    private final Consumer<TaskFailureInfo> failCallback;

    /**
     * This will be called when both the original task and the speculative task succeed. Only
     * one of this field and {@link #taskCanceller} should be supplied.
     */
    @Nullable
    private final Consumer<Object> duplicatedTaskSucceedsCallback;

    /**
     * The time when this task was submitted to {@link SpeculativeTasksManager}. There's a chance
     * that this task is submitted and queued without being executed immediately. We ignore the
     * difference, as this is just an optimization.
     */
    private long submittedTime;

    //---------------------------------------------------------------------------------------------
    // Internal states used by the speculative task framework. These state should not be accessed
    // by the users.
    //---------------------------------------------------------------------------------------------

    /**
     * Whether the task submitted by the user succeeded. If it is {@literal false}, we cannot say
     * that the task failed. We can only tell that the task has failed from the field
     * {@link #originalTaskFailed}.
     */
    private volatile boolean originalTaskSucceeded = false;

    /**
     * Whether the task submitted by the user failed.
     */
    private volatile boolean originalTaskFailed = false;

    /**
     * Whether the task submitted by the user takes long enough, and the framework has submitted a
     * speculative task for it.
     */
    private volatile boolean speculatedTaskSubmitted = false;

    /**
     * Whether the speculative task succeeded. If it is {@literal false}, we cannot say
     * that the task failed. We can only tell that the task has failed from the field
     * {@link #speculatedTaskFailed}.
     */
    private volatile boolean speculatedTaskSucceeded = false;

    /**
     * Whether the speculative task failed.
     */
    private volatile boolean speculatedTaskFailed = false;

    /**
     * Task data associated with the original task.
     */
    private @Nullable Object originalTaskData = null;

    /**
     * Task data associated with the speculated task.
     */
    private @Nullable Object speculatedTaskData = null;

    /**
     * Whether failed callback was called.
     */
    private volatile boolean hasCalledFailedCallback = false;

    /**
     * If true, it will be removed while traversing tasks.
     */
    private volatile boolean finished = false;

    /**
     * original task.
     */
    private OriginalTask originalTask = null;

    /**
     * speculative task.
     */
    private SpeculatedTask speculatedTask = null;

    /**
     * final failure info
     */
    private volatile TaskFailureInfo finalfailureInfo = null;

    /**
     * Make sure that only one task between the speculative task
     * and the original task can change the internal state.
     */
    private final Object lock = new Object();

    private SpeculativeTaskInfo(
            String taskType,
            @Nullable Supplier<Object> taskDataGenerator,
            @Nonnull Function<Object, Object> task,
            @Nullable Consumer<Future<?>> taskCanceller,
            @Nullable Consumer<Object> succeedCallback,
            @Nonnull Consumer<TaskFailureInfo> failCallback,
            @Nullable Consumer<Object> duplicatedTaskSucceedsCallback) {
        this.taskType = taskType;
        this.taskDataGenerator = taskDataGenerator;
        this.task = task;
        this.taskCanceller = taskCanceller;
        this.succeedCallback = succeedCallback;
        this.failCallback = failCallback;
        this.duplicatedTaskSucceedsCallback = duplicatedTaskSucceedsCallback;
    }

    /*--------------------Getter/Setter--------------------*/

    public long getSubmittedTime() {
        return submittedTime;
    }

    public String getTaskType() {
        return taskType;
    }

    public boolean isOriginalTaskSucceeded() {
        return originalTaskSucceeded;
    }

    public boolean isSpeculatedTaskSubmitted() {
        return speculatedTaskSubmitted;
    }

    public void setSpeculatedTaskSubmitted(boolean speculatedTaskSubmitted) {
        this.speculatedTaskSubmitted = speculatedTaskSubmitted;
    }

    public boolean isFinished() {
        return finished;
    }

    public void setOriginalTask(OriginalTask originalTask) {
        this.originalTask = originalTask;
    }

    public void setSpeculatedTask(SpeculatedTask speculatedTask) {
        this.speculatedTask = speculatedTask;
    }

    private boolean isOriginalTaskRunning() {
        return submittedTime > 0 && !originalTaskFailed && !originalTaskSucceeded;
    }

    private boolean isSpeculatedTaskRunning() {
        return speculatedTaskSubmitted && !speculatedTaskFailed && !speculatedTaskSucceeded;
    }

    public OriginalTask getOriginalTask() {
        return originalTask;
    }

    @Nonnull
    public Function<Object, Object> getTask() {
        return task;
    }

    @Nullable
    public Consumer<Object> getSucceedCallback() {
        return succeedCallback;
    }

    @Nonnull
    public Consumer<TaskFailureInfo> getFailCallback() {
        return failCallback;
    }

    @VisibleForTesting
    boolean isSpeculativeTaskSucceeded() {
        return speculatedTaskSucceeded;
    }

    @VisibleForTesting
    SpeculatedTask getSpeculatedTask() {
        return speculatedTask;
    }

    private void fillFinalfailureInfo(TaskFailureInfo finalfailureInfo) {
        while (true) {
            TaskFailureInfo currentFailureInfo = this.finalfailureInfo;
            if (FAILURE_INFO_UPDATER.compareAndSet(
                    this,
                    currentFailureInfo,
                    finalfailureInfo.combine(currentFailureInfo))) {
                break;
            }
        }
    }


    /*--------------------Task Running--------------------*/

    public class OriginalTask extends CancellableTask {

        public OriginalTask(SpeculativeTasksManager speculativeTasksManager) {
            super(speculativeTasksManager);
        }

        @Override
        public Object beforeInvoke() {
            Object taskData = null;
            if (taskDataGenerator != null) {
                taskData = taskDataGenerator.get();
            }
            originalTaskData = taskData;

            // Save the actual running timestamp to avoid incorrect cost
            // due to the busy thread pool
            onSubmitted();
            return taskData;
        }

        @Override
        public void onSubmitted() {
            submittedTime = System.currentTimeMillis();
        }


        @Override
        public void onDuplicated(Object result) throws Exception {
            if (speculatedTaskSucceeded && duplicatedTaskSucceedsCallback != null) {
                duplicatedTaskSucceedsCallback.accept(result);
            }
        }

        @Override
        public void onException(Exception exception) {
            originalTaskFailed = true;
            TaskFailureInfo taskFailureInfo = new TaskFailureInfo(
                    true,
                    originalTaskData,
                    speculatedTaskSubmitted,
                    speculatedTaskFailed,
                    speculatedTaskData,
                    exception);
            fillFinalfailureInfo(taskFailureInfo);
            if (!isSpeculatedTaskRunning() && !hasCalledFailedCallback) {
                hasCalledFailedCallback = true;
                failCallback.accept(finalfailureInfo);
            }

            if (speculatedTaskSucceeded) {
                return;
            }

            // NOTE: If the original task fails with an unknown exception before
            // the speculated task is submitted, we will not submit speculative task,
            // because this error may not be retryable.
            if (!speculatedTaskSubmitted) {
                finished = true;
            }
            LOG.error("Failed to execute original task of type {} with data={}", taskType, originalTaskData, exception);
        }

        @Override
        public void onSucceeded(Object result) {
            originalTaskSucceeded = true;

            if (isSpeculatedTaskRunning()) {
                speculatedTask.cancel();
            }
            if (succeedCallback != null) {
                succeedCallback.accept(result);
            }

            finished = true;
        }

        @Override
        public void onTimeout() {
            // Submit a speculative task
            ExecutorService taskExecutor = getExecutorService();
            SpeculatedTask speculatedTask = new SpeculatedTask(speculativeTasksManager);
            speculatedTask.setTaskFuture(taskExecutor.submit(speculatedTask));
            setSpeculatedTask(speculatedTask);
            speculatedTask.onSubmitted();
        }
    }

    public class SpeculatedTask extends CancellableTask {

        private SpeculatedTask(SpeculativeTasksManager speculativeTasksManager) {
            super(speculativeTasksManager);
        }

        @Override
        public Object beforeInvoke() {
            Object taskData = null;
            if (taskDataGenerator != null) {
                taskData = taskDataGenerator.get();
            }
            speculatedTaskData = taskData;
            return taskData;
        }

        @Override
        public void onException(Exception exception) {
            speculatedTaskFailed = true;
            TaskFailureInfo taskFailureInfo = new TaskFailureInfo(
                    originalTaskFailed,
                    originalTaskData,
                    true,
                    true,
                    speculatedTaskData,
                    exception);
            fillFinalfailureInfo(taskFailureInfo);
            if (!isOriginalTaskRunning() && !hasCalledFailedCallback) {
                hasCalledFailedCallback = true;
                failCallback.accept(finalfailureInfo);
            }
            finished = true;
            if (originalTaskSucceeded) {
                return;
            }
            LOG.error("Failed to execute speculative task of type {} with data={}", taskType, speculatedTaskData, exception);
        }

        @Override
        public void onSubmitted() {
            speculatedTaskSubmitted = true;
        }

        @Override
        public void onTimeout() {
            throw new UnsupportedOperationException("Speculative task doesn't support handling timeout.");
        }

        @Override
        public void onDuplicated(Object result) throws Exception {
            if (originalTaskSucceeded && duplicatedTaskSucceedsCallback != null) {
                duplicatedTaskSucceedsCallback.accept(result);
            }
        }

        @Override
        public void onSucceeded(Object result) {
            speculatedTaskSucceeded = true;

            if (isOriginalTaskRunning()) {
                originalTask.cancel();
            }
            if (succeedCallback != null) {
                succeedCallback.accept(result);
            }

            finished = true;
        }
    }


    public abstract class CancellableTask implements Runnable, StateChangeAction {

        protected volatile boolean cancelled = false;

        protected final SpeculativeTasksManager speculativeTasksManager;

        private Future<?> taskFuture;

        public CancellableTask(SpeculativeTasksManager speculativeTasksManager) {
            this.speculativeTasksManager = speculativeTasksManager;
        }

        @Override
        public void run() {
            Object taskInput = beforeInvoke();
            try {
                long start = System.currentTimeMillis();
                Object result = task.apply(taskInput);
                long cost = System.currentTimeMillis() - start;
                afterInvoke(result, cost);
            } catch (Exception e) {
                onException(e);
            }
        }

        public void cancel() {
            cancelled = true;
            if (taskFuture != null && taskCanceller != null) {
                taskCanceller.accept(taskFuture);
            }
        }

        protected void report(String taskType, long timeCost) {
            ((SpeculativeTasksManagerImpl) speculativeTasksManager).reportTimeCost(taskType, timeCost);
        }

        protected ExecutorService getExecutorService() {
            return ((SpeculativeTasksManagerImpl) speculativeTasksManager).getTaskExecutors().get(taskType);
        }

        protected void setTaskFuture(Future<?> taskFuture) {
            this.taskFuture = taskFuture;
        }

        public abstract Object beforeInvoke();

        public void afterInvoke(Object result, long cost) throws Exception {
            synchronized (lock) {
                if (cancelled) {
                    // NOTE: The task may not actually be canceled, so we need to call
                    //       the duplicated method to ensure the accuracy of the result.
                    onDuplicated(result);
                    return;
                }
                report(taskType, cost);
                onSucceeded(result);
            }
        }
    }

    /**
     * Define some actions when state changes.
     */
    interface StateChangeAction {

        /**
         *  It fires after the task is submitted.
         */
        void onSubmitted();

        /**
         * Exception handling after the task encounters an exception.
         * @param exception e
         */
        void onException(Exception exception);

        /**
         *  It fires after the task time out.
         */
        void onTimeout();

        /**
         * Handle the result after the task is successful.
         * @param result result
         */
        void onSucceeded(Object result);

        /**
         * When both original and speculative tasks are completed,
         * call this method for processing to ensure the correctness of the returned data.
         * @param result result
         * @throws Exception e
         */
        void onDuplicated(Object result) throws Exception;

    }


    /*--------------------Builder--------------------*/
    public static class SpeculativeTaskInfoBuilder {
        private final String taskType;

        private Supplier<Object> taskDataGenerator = null;

        private final Function<Object, Object> task;

        private Consumer<Future<?>> taskCanceller = null;

        private Consumer<Object> succeedCallback = null;

        private Consumer<TaskFailureInfo> failCallback = null;

        private Consumer<Object> duplicatedTaskSucceedsCallback = null;

        public SpeculativeTaskInfoBuilder(
                String taskType,
                Function<Object, Object> task) {
            this.taskType = taskType;
            this.task = task;
        }

        public SpeculativeTaskInfoBuilder setTaskDataGenerator(Supplier<Object> taskDataGenerator) {
            this.taskDataGenerator = taskDataGenerator;
            return this;
        }

        public SpeculativeTaskInfoBuilder setTaskCanceller(Consumer<Future<?>> taskCanceller) {
            this.taskCanceller = taskCanceller;
            return this;
        }

        public SpeculativeTaskInfoBuilder setSucceedCallback(Consumer<Object> succeedCallback) {
            this.succeedCallback = succeedCallback;
            return this;
        }

        public SpeculativeTaskInfoBuilder setFailCallback(
                Consumer<TaskFailureInfo> failCallback) {
            this.failCallback = failCallback;
            return this;
        }

        public SpeculativeTaskInfoBuilder setDuplicatedTaskSucceedsCallback(
                Consumer<Object> duplicatedTaskSucceedsCallback) {
            this.duplicatedTaskSucceedsCallback = duplicatedTaskSucceedsCallback;
            return this;
        }

        public SpeculativeTaskInfo build() {
            return new SpeculativeTaskInfo(
                    this.taskType,
                    this.taskDataGenerator,
                    this.task,
                    this.taskCanceller,
                    this.succeedCallback,
                    this.failCallback,
                    this.duplicatedTaskSucceedsCallback);
        }
    }

    public static class TaskFailureInfo {
        private final boolean originalTaskFailed;
        private final Object originalTaskData;
        private final Boolean speculatedTaskSubmitted;
        private final Boolean speculatedTaskFailed;
        @Nullable
        private final Object speculatedTaskData;
        private final Throwable executionException;

        public TaskFailureInfo(
                boolean originalTaskFailed,
                Object originalTaskData,
                boolean speculatedTaskSubmitted,
                boolean speculatedTaskFailed,
                @Nullable Object speculatedTaskData,
                Throwable executionException) {
            this.originalTaskFailed = originalTaskFailed;
            this.originalTaskData = originalTaskData;
            this.speculatedTaskSubmitted = speculatedTaskSubmitted;
            this.speculatedTaskFailed = speculatedTaskFailed;
            this.speculatedTaskData = speculatedTaskData;
            this.executionException = executionException;
        }

        public boolean isOriginalTaskFailed() {
            return originalTaskFailed;
        }

        public Object getOriginalTaskData() {
            return originalTaskData;
        }

        @Nullable
        public Object getSpeculatedTaskData() {
            return speculatedTaskData;
        }

        public Throwable getExecutionException() {
            return executionException;
        }

        public boolean isSpeculatedTaskSubmitted() {
            return speculatedTaskSubmitted;
        }

        public boolean isSpeculatedTaskFailed() {
            return speculatedTaskFailed;
        }

        /**
         * Combine this with first failure.
         * To avoid judge the results twice when using, we will call
         * failed callback only once, but the taskFailureInfo may contain two execution results.
         * @param first the first taskFailureInfo
         * @return final taskFailureInfo
         */
        public TaskFailureInfo combine(TaskFailureInfo first) {
            if (first == null) {
                return this;
            }
            return new TaskFailureInfo(
                    this.originalTaskFailed || first.originalTaskFailed,
                    getNoNullValue(this.originalTaskData, first.originalTaskData),
                    this.speculatedTaskSubmitted || first.speculatedTaskSubmitted,
                    this.speculatedTaskFailed || first.speculatedTaskFailed,
                    getNoNullValue(this.speculatedTaskData, first.speculatedTaskData),
                    ExceptionUtils.firstOrSuppressed(this.executionException, first.executionException));
        }

        private Object getNoNullValue(Object value1, Object value2) {
            if (value1 == null) {
                return value2;
            } else {
                return value1;
            }
        }

        @Override
        public String toString() {
            return "TaskFailureInfo{" +
                    "originalTaskFailed=" + originalTaskFailed +
                    ", originalTaskData=" + originalTaskData +
                    ", speculatedTaskSubmitted=" + speculatedTaskSubmitted +
                    ", speculatedTaskFailed=" + speculatedTaskFailed +
                    ", speculatedTaskData=" + speculatedTaskData +
                    ", executionException=" + executionException +
                    '}';
        }
    }
}
